# Case Study: spec-implementer

> Source-verified lessons from the spec-implementer Claude Code plugin for MangleCP protocol design.
> Based on actual Go source code, .mg schema, skill files, and command definitions.

---

## Overview

spec-implementer is a Claude Code MCP server plugin that takes structured feature specifications (generated by its sister plugin `symbiogen-spec-generator`) and orchestrates their implementation through Mangle-powered task classification, dependency sequencing, agent assignment, and context-scoped prompt generation. It is a **consumer** of Mangle reasoning: facts are seeded from parsed spec markdown, rules derive which phases are ready, which agents to assign, and which context files to include in prompts.

Where BrowserNERD uses Mangle to reason about **browser state**, spec-implementer uses Mangle to reason about **implementation workflow state**. This makes it a closer analog to MangleCP's intent-scoped tool synthesis model.

---

## Source-Verified Architecture

### Actual Codebase Stats

| Component | File(s) | Lines | Key Insight |
|-----------|---------|-------|-------------|
| Mangle Engine | `mcp-server/internal/mangle/engine.go` | 280 | `SimpleInMemoryStore`, same dual-store pattern as BrowserNERD |
| Schema | `mcp-server/data/mangle-rules/spec-impl.mg` | 474 | 30 predicates, 28 deductive rules, 10 sections |
| MCP Server | `mcp-server/internal/mcp/server.go` | 1,660 | 17 tools, prompt builders, fact seeding |
| Spec Parser | `mcp-server/internal/parser/spec_parser.go` | 805 | Markdown-to-facts pipeline |
| Progress Tracker | `mcp-server/internal/progress/tracker.go` | 273 | In-memory + JSON file progress |
| SQLite Store | `mcp-server/internal/store/*.go` | ~1,080 | 9 tables: facts, progress, snippets, tests |
| SQL Migrations | `mcp-server/internal/store/migrations/001_initial.sql` | 130 | Full schema |
| Skills | `skills/*/SKILL.md` | 329 | execution-strategy (219), spec-parsing (109) |
| Subagents | `agents/*.md` | 291 | complex-implementer, mechanical-implementer, unit-test-grinder |
| Commands | `commands/*.md` | 370 | `/implement` (304), `/status` (66) |

**Total source lines: ~5,700**

### Actual Tool Count from `server.go`

The `registerTools()` method registers **17 MCP tools**:

| # | Tool Name | Category | Mangle-Backed? |
|---|-----------|----------|----------------|
| 1 | `load_spec` | Spec Loading | Seeds facts |
| 2 | `get_execution_plan` | Planning | Yes |
| 3 | `get_phase_context` | Context | Yes |
| 4 | `get_agent_prompt` | Context | Yes (`needs_file`, `needs_react_practices`) |
| 5 | `get_step_code` | Context | No |
| 6 | `mark_phase_status` | Progress | Pushes facts |
| 7 | `mark_step_status` | Progress | Pushes facts |
| 8 | `record_test_results` | Progress | Pushes facts |
| 9 | `record_file` | Progress | Pushes facts |
| 10 | `record_issue` | Progress | Pushes facts |
| 11 | `get_progress` | Query | No |
| 12 | `get_ready_phases` | Query | Yes (`ready_phase`) |
| 13 | `get_blocking_issues` | Query | Yes (`blocking_dep`, `test_gate_failed`) |
| 14 | `get_test_ledger` | Query | No |
| 15 | `get_file_inventory` | Query | No |
| 16 | `get_spec_content` | Context | No |
| 17 | `query` | Raw Mangle | Yes (arbitrary) |

Of the 17 tools, **5 are directly backed by Mangle queries**, **6 push facts that trigger re-evaluation**, and the remaining 6 are pure data access.

---

## Key Patterns Worth Adopting

### 1. Mangle-Driven Context Selection (`needs_file`)

This is the **single most MangleCP-relevant pattern** in the project. The `.mg` schema defines rules that determine which spec files a subagent needs for a given implementation phase:

```mangle
needs_file(Spec, Phase, "README.md") :-
    phase(Spec, Phase, _, _).

needs_file(Spec, Phase, "04-api-contracts.md") :-
    step_type(Spec, Phase, _, "backend").

needs_file(Spec, Phase, "05-graph-schema.md") :-
    step_type(Spec, Phase, _, "database").

needs_file(Spec, Phase, "02-cross-system-map.md") :-
    has_backend_step(Spec, Phase),
    has_frontend_step(Spec, Phase).
```

The Go prompt builder queries `needs_file(SpecId, Phase, File).` and includes only the matched files in the generated prompt (`server.go:1218`). This is **intent-scoped context injection**: the server uses rule evaluation to decide what context is relevant, rather than dumping everything.

**MangleCP lesson:** This is the `context_injection.skills` field from the whitepaper in action. The server proves which context is needed and includes only that. MangleCP should formalize this pattern: skills/resources are injected when and only when a rule proves them necessary.

### 2. Mangle-Driven Agent Assignment

Rules map task complexity to agent types:

```mangle
agent_for_step(Spec, Phase, Step, "mechanical-implementer") :-
    task_complexity(Spec, Phase, Step, "mechanical").

agent_for_step(Spec, Phase, Step, "complex-implementer") :-
    task_complexity(Spec, Phase, Step, "complex").

agent_for_step(Spec, Phase, Step, "unit-test-grinder") :-
    task_complexity(Spec, Phase, Step, "test").
```

The orchestrator queries `agent_for_step` to determine which subagent to spawn. Agents have **differentiated MCP tool access** defined in their frontmatter: implementation agents get `get_step_code`, `get_phase_context`, `record_file`, `record_issue`; the unit-test-grinder gets **zero** MCP tools and works from prompt context alone.

**MangleCP lesson:** Macro-tools could carry access-control metadata. A MangleCP server could compute not just *which* tool to expose, but *which subset of capabilities* each invocation context should have.

### 3. Skill-Mangle Parallel Encoding

The skills and Mangle rules encode the **same domain logic from different angles**:

| Concept | Mangle Rule (spec-impl.mg) | Skill Reference |
|---------|---------------------------|-----------------|
| Agent assignment | `agent_for_step(S, P, St, Agent)` | execution-strategy: "Model Tier Classification" |
| Phase readiness | `ready_phase(S, P, Name, Goal)` | execution-strategy: "Dependency-Aware Sequencing" |
| Integration tests | `needs_integration_tests(S, P)` | execution-strategy: "test-architect" escalation |
| Context file selection | `needs_file(S, P, File)` | spec-parsing: spec file role table |
| Complexity classification | `task_complexity(S, P, St, C)` | spec-parsing: "Complexity classification" criteria |
| React practices | `needs_react_practices(S, P)` | execution-strategy: "React Best Practices" |

Skills provide human-readable instructions for the orchestrating agent; Mangle rules provide machine-queryable derivations for the MCP server. They are **two representations of the same knowledge**.

**MangleCP lesson:** MangleCP skills (human instructions) and Mangle rules (machine logic) should be designed together. When a MangleCP server includes a skill in `required_skills`, there should be a corresponding rule that proved it necessary. The protocol should formalize this skill-rule binding.

### 4. Self-Contained Prompt Generation

The `get_agent_prompt` tool generates prompts that are **completely self-contained** -- agents need zero conversation history. From `server.go:134`:

```
NOTE: This is the primary way to get work done. Agents receiving this prompt
need NO additional context from conversation history.
```

The prompt includes (from `buildImplementationPrompt`, `server.go:1054-1212`):
- Feature context (README summary)
- Full raw phase prose (from `03-implementation-plan.md`)
- Mangle-selected context files (`needs_file` query results)
- Step summary table with code snippet references
- React best practices (if `needs_react_practices` fires)
- Dependencies and verification commands

React best practices are injected by server-side code when the Mangle rule fires (`server.go:1176-1183`):

```go
if hasFrontend {
    sb.WriteString("## Frontend React Standards\n")
    sb.WriteString("Apply react-best-practices skill. Key rules:\n")
    sb.WriteString("- Import directly from modules, avoid barrel files\n")
    // ...
}
```

**MangleCP lesson:** Macro-tool payloads should be self-contained. The `context_injection` field should carry everything needed for execution. spec-implementer proves this works in production.

### 5. Suspend/Resume Bulk Evaluation

The engine implements `SuspendEval()` / `ResumeEval()` for bulk fact loading during spec ingestion (`server.go:365-367`):

```go
s.engine.SuspendEval()
s.seedMangleFacts(spec)  // seeds 19 predicate types
s.engine.ResumeEval()    // single full derivation pass
```

The `seedMangleFacts()` function (`server.go:1375-1464`) pushes facts for specs, phases, steps, step types, complexity classifications, code snippets, dependencies, API endpoints, models, collections, indexes, edges, agent modifications, graph registrations, components, risks, decisions, and open questions.

After initial load, individual fact additions (progress updates, test results) trigger incremental `EvalProgram`, so derived predicates like `ready_phase` update in real-time.

### 6. Reactive Fact-Driven Workflow

When an orchestrator calls `mark_phase_status(phase=1, status="done")`, the server:
1. Updates the in-memory progress tracker
2. Pushes `phase_status(SpecId, 1, "done")` to the Mangle store
3. Triggers `engine.EvalProgram`
4. `ready_phase` **automatically re-derives** for phases that depended on phase 1

The next call to `get_ready_phases` immediately reflects the updated state. This is **closed-loop reactive reasoning**: fact mutations drive rule re-evaluation which drives tool behavior.

### 7. Cross-Phase Conflict Detection

The schema includes rules for detecting file conflicts across parallel phases:

```mangle
multi_phase_file(Spec, File, P1, P2) :-
    file_modified(Spec, P1, File),
    file_modified(Spec, P2, File),
    P1 != P2.
```

And production dependency tracking:

```mangle
produces_for(Spec, Producer, Consumer, File) :-
    file_created(Spec, Producer, File),
    step(Spec, Consumer, _, _, File),
    phase_depends(Spec, Consumer, Producer).
```

**MangleCP lesson:** MangleCP servers could derive conflict detection and dependency tracking from facts about macro-tool invocation results, using the `state_delta` in invoke responses.

---

## Things to Improve On

### 1. No Temporal Store

Uses `factstore.NewSimpleInMemoryStore()`. The schema has commented-out DatalogMTL stale-phase detection:

```mangle
# Decl stale_phase(I, P) at [T1, T2].
# stale_phase(Spec, Phase) at [T, T+3600000] :-
#     phase_status(Spec, Phase, "in_progress") at [T, _].
```

Note: *"Temporal features pending Mangle LSP update."*

**MangleCP improvement:** DatalogMTL would enable stale-phase detection, time-bounded progress analysis, and SLA enforcement natively. MangleCP's `eval_time` field was designed for exactly this.

### 2. Skills Are Loaded by Client, Not Server

The `/implement` command instructs the orchestrator to load skills:

```markdown
Load the **spec-parsing** and **execution-strategy** skills to guide the process.
```

The Go server does NOT read skill files. Skill knowledge is **hardcoded into prompt builders**. This means skills and server logic can drift.

**MangleCP improvement:** MangleCP should inject skills server-side. When `needs_react_practices(Spec, Phase)` fires, the server should include the skill payload in `required_skills`, not rely on the client to independently load it.

### 3. No Evaluation Safety Limits

No timeout, fact-creation limit, or interval cap on `EvalProgram`. The schema is small enough that non-termination isn't a practical risk, but it's architecturally unsound.

### 4. Fallback-Heavy Architecture

Multiple fallbacks suggest incomplete confidence in Mangle:

- `computeReadyPhasesFallback()` when Mangle queries fail (`server.go:1532`)
- `getNeededFiles()` falls back to heuristic selection (`server.go:1232`)
- Engine init failure: server continues in "query fallback mode" (`main.go:48-51`)

---

## Architecture Decisions to Question

| Pattern | Worth Keeping? | Why |
|---|---|---|
| `SimpleInMemoryStore` | **No** -- use `TemporalStore` | Temporal phase tracking is explicitly desired |
| Dual-store (Mangle + SQLite) | **Yes** | Cross-session persistence is essential |
| Suspend/Resume bulk eval | **Yes** | Efficient for initial fact loading |
| Skill-Mangle parallel encoding | **Formalize** | Great pattern, needs synchronization mechanism |
| Self-contained prompt generation | **Yes** | Core pattern for MangleCP macro-tools |
| `needs_file` context selection | **Adopt as canonical** | This IS MangleCP's intent-scoped context injection |
| Agent tool access restrictions | **Adopt** | Principle of least privilege for macro-tools |
| Fallback-heavy approach | **Reduce** | MangleCP should be confident in its engine |

---

## Summary

spec-implementer demonstrates MangleCP's core thesis in a workflow orchestration domain: **Mangle rules determine what context to inject, which agent to assign, and which phases are ready** -- all derived from facts seeded from parsed specification documents. The `needs_file` predicate is the closest existing implementation to MangleCP's intent-scoped tool synthesis: a rule-proven selection of exactly the context needed, nothing more. The skill-Mangle parallel encoding pattern shows how human instructions and machine logic can co-exist but also reveals the need for a formal mechanism to keep them synchronized. MangleCP should adopt `needs_file`-style context injection as a first-class protocol pattern and formalize the relationship between skills and the rules that trigger them.
